{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Lightweight ASGI Web Framework \u00b6 This is a web framework for ASGI servers in Python 3.7. The goal is to provide a minimal implementation, with other facilities (serving static files, CORS, sessions, etc.) being implemented by optional packages in an attempt to keep the implementation clear and lightweight.","title":"Lightweight ASGI Web Framework"},{"location":"#lightweight-asgi-web-framework","text":"This is a web framework for ASGI servers in Python 3.7. The goal is to provide a minimal implementation, with other facilities (serving static files, CORS, sessions, etc.) being implemented by optional packages in an attempt to keep the implementation clear and lightweight.","title":"Lightweight ASGI Web Framework"},{"location":"api/bareasgi/","text":"API \u00b6 class Application \u00b6 Summary \u00b6 Construct the application bareasgi . Application ( * , http_router : Optional[HttpRouter] , web_socket_router : Optional[WebSocketRouter] , startup_handlers : Optional[List[LifespanHandler]] , shutdown_handlers : Optional[List[LifespanHandler]] , not_found_response : Optional[HttpResponse] , info : Optional[MutableMapping[str ) -> None Parameters \u00b6 http_router : Optional[HttpRouter] Optional router to for http routes. Defaults to None. web_socket_router : Optional[WebSocketRouter] Optional router for web routes. Defaults to None. startup_handlers : Optional[List[LifespanHandler]] Optional handlers to run at startup. Defaults to None. shutdown_handlers : Optional[List[LifespanHandler]] Optional handlers to run at shutdown. Defaults to None. not_found_response : Optional[HttpResponse] Optional not found (404) response. Defaults to None. info : Optional[MutableMapping[str Optional dictionary for user data. Defaults to None. Description \u00b6 from bareasgi import ( Application , Scope , Info , RouteMatches , Content , WebSocket , text_reader , text_writer ) async def http_request_callback ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse : text = await text_reader ( content ) return 200 , [( b 'content-type' , b 'text/plain' )], text_writer ( 'This is not a test' ), None import uvicorn app = Application () app . http_router . add ({ 'GET' , 'POST' , 'PUT' , 'DELETE' }, '/ {path} ' , http_request_callback ) uvicorn . run ( app , port = 9009 ) property Application . http_router \u00b6 Summary \u00b6 Router for http routes http_router -> HttpRouter property Application . info \u00b6 Summary \u00b6 A place to sto application specific data. info -> MutableMapping[str, Any] property Application . middlewares \u00b6 Summary \u00b6 The middlewares. middlewares -> List[HttpMiddlewareCallback] property Application . shutdown_handlers \u00b6 Summary \u00b6 Handlers run on shutdown shutdown_handlers -> List[LifespanHandler] property Application . startup_handlers \u00b6 Summary \u00b6 Handlers run at startup startup_handlers -> List[LifespanHandler] property Application . ws_router \u00b6 Summary \u00b6 Router for WebSocket routes ws_router -> WebSocketRouter method Application . on_http_request \u00b6 Summary \u00b6 A decorator to add an http route handler to the application Application . on_http_request ( methods : AbstractSet[str] , path : str ) -> Callable[[HttpRequestCallback], HttpRequestCallback] Parameters \u00b6 methods : AbstractSet[str] (optional) The http methods, e.g. {{'POST', 'PUT'} path : str (optional) The path Returns \u00b6 Callable[[HttpRequestCallback], HttpRequestCallback] : The decorated request. method Application . on_shutdown \u00b6 Summary \u00b6 A decorator to add a startup handler to the application Application . on_shutdown ( callback : LifespanHandler ) -> Callable[[LifespanHandler], LifespanHandler] Parameters \u00b6 callback : LifespanHandler (optional) The shutdown handler. Returns \u00b6 Callable[[LifespanHandler], LifespanHandler] : The decorated handler. method Application . on_startup \u00b6 Summary \u00b6 A decorator to add a startup handler to the application Application . on_startup ( callback : LifespanHandler ) -> Callable[[LifespanHandler], LifespanHandler] Parameters \u00b6 callback : LifespanHandler (optional) The startup handler. Returns \u00b6 Callable[[LifespanHandler], LifespanHandler] : The decorated handler. method Application . on_ws_request \u00b6 Summary \u00b6 A decorator to add a websocket route handler to the application Application . on_ws_request ( path : str ) -> Callable[[WebSocketRequestCallback], WebSocketRequestCallback] Parameters \u00b6 path : str (optional) The path Returns \u00b6 Callable[[WebSocketRequestCallback], WebSocketRequestCallback] : The decorated handler","title":"bareasgi"},{"location":"api/bareasgi/#api","text":"","title":"API"},{"location":"api/bareasgi/#class-application","text":"","title":"class Application"},{"location":"api/bareasgi/#summary","text":"Construct the application bareasgi . Application ( * , http_router : Optional[HttpRouter] , web_socket_router : Optional[WebSocketRouter] , startup_handlers : Optional[List[LifespanHandler]] , shutdown_handlers : Optional[List[LifespanHandler]] , not_found_response : Optional[HttpResponse] , info : Optional[MutableMapping[str ) -> None","title":"Summary"},{"location":"api/bareasgi/#parameters","text":"http_router : Optional[HttpRouter] Optional router to for http routes. Defaults to None. web_socket_router : Optional[WebSocketRouter] Optional router for web routes. Defaults to None. startup_handlers : Optional[List[LifespanHandler]] Optional handlers to run at startup. Defaults to None. shutdown_handlers : Optional[List[LifespanHandler]] Optional handlers to run at shutdown. Defaults to None. not_found_response : Optional[HttpResponse] Optional not found (404) response. Defaults to None. info : Optional[MutableMapping[str Optional dictionary for user data. Defaults to None.","title":"Parameters"},{"location":"api/bareasgi/#description","text":"from bareasgi import ( Application , Scope , Info , RouteMatches , Content , WebSocket , text_reader , text_writer ) async def http_request_callback ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse : text = await text_reader ( content ) return 200 , [( b 'content-type' , b 'text/plain' )], text_writer ( 'This is not a test' ), None import uvicorn app = Application () app . http_router . add ({ 'GET' , 'POST' , 'PUT' , 'DELETE' }, '/ {path} ' , http_request_callback ) uvicorn . run ( app , port = 9009 )","title":"Description"},{"location":"api/bareasgi/#property-applicationhttp_router","text":"","title":"property Application.http_router"},{"location":"api/bareasgi/#summary_1","text":"Router for http routes http_router -> HttpRouter","title":"Summary"},{"location":"api/bareasgi/#property-applicationinfo","text":"","title":"property Application.info"},{"location":"api/bareasgi/#summary_2","text":"A place to sto application specific data. info -> MutableMapping[str, Any]","title":"Summary"},{"location":"api/bareasgi/#property-applicationmiddlewares","text":"","title":"property Application.middlewares"},{"location":"api/bareasgi/#summary_3","text":"The middlewares. middlewares -> List[HttpMiddlewareCallback]","title":"Summary"},{"location":"api/bareasgi/#property-applicationshutdown_handlers","text":"","title":"property Application.shutdown_handlers"},{"location":"api/bareasgi/#summary_4","text":"Handlers run on shutdown shutdown_handlers -> List[LifespanHandler]","title":"Summary"},{"location":"api/bareasgi/#property-applicationstartup_handlers","text":"","title":"property Application.startup_handlers"},{"location":"api/bareasgi/#summary_5","text":"Handlers run at startup startup_handlers -> List[LifespanHandler]","title":"Summary"},{"location":"api/bareasgi/#property-applicationws_router","text":"","title":"property Application.ws_router"},{"location":"api/bareasgi/#summary_6","text":"Router for WebSocket routes ws_router -> WebSocketRouter","title":"Summary"},{"location":"api/bareasgi/#method-applicationon_http_request","text":"","title":"method Application.on_http_request"},{"location":"api/bareasgi/#summary_7","text":"A decorator to add an http route handler to the application Application . on_http_request ( methods : AbstractSet[str] , path : str ) -> Callable[[HttpRequestCallback], HttpRequestCallback]","title":"Summary"},{"location":"api/bareasgi/#parameters_1","text":"methods : AbstractSet[str] (optional) The http methods, e.g. {{'POST', 'PUT'} path : str (optional) The path","title":"Parameters"},{"location":"api/bareasgi/#returns","text":"Callable[[HttpRequestCallback], HttpRequestCallback] : The decorated request.","title":"Returns"},{"location":"api/bareasgi/#method-applicationon_shutdown","text":"","title":"method Application.on_shutdown"},{"location":"api/bareasgi/#summary_8","text":"A decorator to add a startup handler to the application Application . on_shutdown ( callback : LifespanHandler ) -> Callable[[LifespanHandler], LifespanHandler]","title":"Summary"},{"location":"api/bareasgi/#parameters_2","text":"callback : LifespanHandler (optional) The shutdown handler.","title":"Parameters"},{"location":"api/bareasgi/#returns_1","text":"Callable[[LifespanHandler], LifespanHandler] : The decorated handler.","title":"Returns"},{"location":"api/bareasgi/#method-applicationon_startup","text":"","title":"method Application.on_startup"},{"location":"api/bareasgi/#summary_9","text":"A decorator to add a startup handler to the application Application . on_startup ( callback : LifespanHandler ) -> Callable[[LifespanHandler], LifespanHandler]","title":"Summary"},{"location":"api/bareasgi/#parameters_3","text":"callback : LifespanHandler (optional) The startup handler.","title":"Parameters"},{"location":"api/bareasgi/#returns_2","text":"Callable[[LifespanHandler], LifespanHandler] : The decorated handler.","title":"Returns"},{"location":"api/bareasgi/#method-applicationon_ws_request","text":"","title":"method Application.on_ws_request"},{"location":"api/bareasgi/#summary_10","text":"A decorator to add a websocket route handler to the application Application . on_ws_request ( path : str ) -> Callable[[WebSocketRequestCallback], WebSocketRequestCallback]","title":"Summary"},{"location":"api/bareasgi/#parameters_4","text":"path : str (optional) The path","title":"Parameters"},{"location":"api/bareasgi/#returns_3","text":"Callable[[WebSocketRequestCallback], WebSocketRequestCallback] : The decorated handler","title":"Returns"},{"location":"user-guide/application/","text":"Application \u00b6 The application class has the following constructor: Application ( middlewares : Optional [ List [ HttpMiddlewareCallback ]], http_router : Optional [ HttpRouter ], web_socket_router : Optional [ WebSocketRouter ], startup_handlers : Optional [ List [ StartupHandler ]], shutdown_handlers : Optional [ List [ ShutdownHandler ]], not_found_response : Optional [ HttpResponse ], info : Optional [ MutableMapping [ str , Any ]] ) All arguments are optional. The info argument provides a place for application specific data. The application provides some properties that can be used for configuration: Application . info -> MutableMapping [ str , Any ] Application . middlewares -> List [] Application . http_router -> HttpRouter Application . ws_router -> WebSocketRouter Application . startup_handlers -> List [ StartupHandler ] Application . shutdown_handlers -> List [ ShutdownHandler ]","title":"Application"},{"location":"user-guide/application/#application","text":"The application class has the following constructor: Application ( middlewares : Optional [ List [ HttpMiddlewareCallback ]], http_router : Optional [ HttpRouter ], web_socket_router : Optional [ WebSocketRouter ], startup_handlers : Optional [ List [ StartupHandler ]], shutdown_handlers : Optional [ List [ ShutdownHandler ]], not_found_response : Optional [ HttpResponse ], info : Optional [ MutableMapping [ str , Any ]] ) All arguments are optional. The info argument provides a place for application specific data. The application provides some properties that can be used for configuration: Application . info -> MutableMapping [ str , Any ] Application . middlewares -> List [] Application . http_router -> HttpRouter Application . ws_router -> WebSocketRouter Application . startup_handlers -> List [ StartupHandler ] Application . shutdown_handlers -> List [ ShutdownHandler ]","title":"Application"},{"location":"user-guide/asgi/","text":"ASGI \u00b6 What is ASGI? \u00b6 An ASGI server sits at the front of a web application receiving and sending HTTP and WebSocket messages. The client code simply sends and receives dictionaries which describe the HTTP messages. At it's heart ASGI is a specification. You can find the ASGI specification here . Why? \u00b6 Back in the days of Python 2 where there was no async/await functionality, a lot of effort was required to make a responsive web server in python. Essentially it was necessary to have a separate service which would create a new process to service the request. Out of this emerged the WSGI specification, and Python applications which conformed to the specification could choose from a selection of servers which supported the spec. The ASGI specification is an asynchronous version of WSGI, which supports the async/await functionlity of Python 3. This allows us to write a responsive web service without the necessity of creating multiple processes, although this may still be desirable for more performance. Servers \u00b6 A number of servers have been written that support the specification. I have been using: uvicorn hypercorn","title":"ASGI"},{"location":"user-guide/asgi/#asgi","text":"","title":"ASGI"},{"location":"user-guide/asgi/#what-is-asgi","text":"An ASGI server sits at the front of a web application receiving and sending HTTP and WebSocket messages. The client code simply sends and receives dictionaries which describe the HTTP messages. At it's heart ASGI is a specification. You can find the ASGI specification here .","title":"What is ASGI?"},{"location":"user-guide/asgi/#why","text":"Back in the days of Python 2 where there was no async/await functionality, a lot of effort was required to make a responsive web server in python. Essentially it was necessary to have a separate service which would create a new process to service the request. Out of this emerged the WSGI specification, and Python applications which conformed to the specification could choose from a selection of servers which supported the spec. The ASGI specification is an asynchronous version of WSGI, which supports the async/await functionlity of Python 3. This allows us to write a responsive web service without the necessity of creating multiple processes, although this may still be desirable for more performance.","title":"Why?"},{"location":"user-guide/asgi/#servers","text":"A number of servers have been written that support the specification. I have been using: uvicorn hypercorn","title":"Servers"},{"location":"user-guide/background-tasks/","text":"Background Tasks \u00b6 It is a common requirement to run background tasks while the server is processing requests. For example incoming data might have to be processed before being used in subsequent responses. An important implementation details is that any code which uses the asyncio event loop (e.g. asyncio.Event(), asyncio.Queue(), etc.) must be done in the context of the ASGI server. Failure to do this will lead to errors complaining that the object is owned by a different event loop. This can be achieved by passing the application startup and shutdown handlers: async def my_startup_handler ( scope : Scope , info : Info , request : Message ) -> None : ... async def my_shutdown_handler ( scope : Scope , info : Info , request : Message ) -> None : ... # Create the application with startup and shutdown handlers. app = Application ( startup_handlers = [ my_startup_handler ], shutdown_handlers = [ my_shutdown_handler ] ) The tasks may be one-off or long running. The long-running tasks can be gracefully terminated with shutdown handlers. Here is an example of a long running task which simply ticks every second. async def time_ticker ( shutdown_event : Event ) -> None : while not shutdown_event . is_set (): log . debug ( f 'time: {datetime.now()}' ) try : await asyncio . wait_for ( shutdown_event . wait (), timeout = 1 ) except asyncio . TimeoutError : log . debug ( 'Timeout - normal behaviour when waiting with a timeout' ) except : log . exception ( 'Failure - we should not see this exception' ) log . debug ( 'The time ticker has stopped' ) async def time_ticker_startup_handler ( scope : Scope , info : Info , request : Message ) -> None : # Create an event that can be set when the background task should shutdown. shutdown_event = Event () info [ 'shutdown_event' ] = shutdown_event # Create the background task. info [ 'time_ticker_task' ] = asyncio . create_task ( time_ticker ( shutdown_event )) async def time_ticker_shutdown_handler ( scope : Scope , info : Info , request : Message ) -> None : # Set the shutdown event so the background task can stop gracefully. shutdown_event : Event = info [ 'shutdown_event' ] log . debug ( 'Stopping the time_ticker' ) shutdown_event . set () # Wait for the background task to finish. time_ticker_task : asyncio . Task = info [ 'time_ticker_task' ] log . debug ( 'Waiting for time_ticker' ) await time_ticker_task log . debug ( 'time_ticker shutdown' )","title":"Background Tasks"},{"location":"user-guide/background-tasks/#background-tasks","text":"It is a common requirement to run background tasks while the server is processing requests. For example incoming data might have to be processed before being used in subsequent responses. An important implementation details is that any code which uses the asyncio event loop (e.g. asyncio.Event(), asyncio.Queue(), etc.) must be done in the context of the ASGI server. Failure to do this will lead to errors complaining that the object is owned by a different event loop. This can be achieved by passing the application startup and shutdown handlers: async def my_startup_handler ( scope : Scope , info : Info , request : Message ) -> None : ... async def my_shutdown_handler ( scope : Scope , info : Info , request : Message ) -> None : ... # Create the application with startup and shutdown handlers. app = Application ( startup_handlers = [ my_startup_handler ], shutdown_handlers = [ my_shutdown_handler ] ) The tasks may be one-off or long running. The long-running tasks can be gracefully terminated with shutdown handlers. Here is an example of a long running task which simply ticks every second. async def time_ticker ( shutdown_event : Event ) -> None : while not shutdown_event . is_set (): log . debug ( f 'time: {datetime.now()}' ) try : await asyncio . wait_for ( shutdown_event . wait (), timeout = 1 ) except asyncio . TimeoutError : log . debug ( 'Timeout - normal behaviour when waiting with a timeout' ) except : log . exception ( 'Failure - we should not see this exception' ) log . debug ( 'The time ticker has stopped' ) async def time_ticker_startup_handler ( scope : Scope , info : Info , request : Message ) -> None : # Create an event that can be set when the background task should shutdown. shutdown_event = Event () info [ 'shutdown_event' ] = shutdown_event # Create the background task. info [ 'time_ticker_task' ] = asyncio . create_task ( time_ticker ( shutdown_event )) async def time_ticker_shutdown_handler ( scope : Scope , info : Info , request : Message ) -> None : # Set the shutdown event so the background task can stop gracefully. shutdown_event : Event = info [ 'shutdown_event' ] log . debug ( 'Stopping the time_ticker' ) shutdown_event . set () # Wait for the background task to finish. time_ticker_task : asyncio . Task = info [ 'time_ticker_task' ] log . debug ( 'Waiting for time_ticker' ) await time_ticker_task log . debug ( 'time_ticker shutdown' )","title":"Background Tasks"},{"location":"user-guide/decorators/","text":"Decorators \u00b6 For small applications it can be more convenient to use decorators for add route and lifespan handlers. Here's a quick example: import uvicorn from bareasgi import Application , text_writer app = Application () @app . on_startup async def my_startup_handler ( scope , info , message ): print ( 'Starting up' ) @app . on_shutdown async def my_shutdown_handler ( scope , info , message ): print ( 'Shutting down' ) @app . on_http_request ({ 'GET' }, '/{rest:path}' ) async def http_request_callback ( scope , info , matches , content ): return 200 , [( b 'content-type' , b 'text/plain' )], text_writer ( 'This is not a test' ) uvicorn . run ( app , port = 9009 )","title":"Decorators"},{"location":"user-guide/decorators/#decorators","text":"For small applications it can be more convenient to use decorators for add route and lifespan handlers. Here's a quick example: import uvicorn from bareasgi import Application , text_writer app = Application () @app . on_startup async def my_startup_handler ( scope , info , message ): print ( 'Starting up' ) @app . on_shutdown async def my_shutdown_handler ( scope , info , message ): print ( 'Shutting down' ) @app . on_http_request ({ 'GET' }, '/{rest:path}' ) async def http_request_callback ( scope , info , matches , content ): return 200 , [( b 'content-type' , b 'text/plain' )], text_writer ( 'This is not a test' ) uvicorn . run ( app , port = 9009 )","title":"Decorators"},{"location":"user-guide/examples/","text":"Examples \u00b6 Here are some examples. More can be found in the github repository here . All the examples use the uvicorn server. Simple \u00b6 Here is a trivial example which registers a single http request callback at the endpoint /test and responds with the plain text This is not a test . 1 2 3 4 5 6 7 8 9 10 from bareasgi import Application , text_writer import uvicorn async def http_request_callback ( scope , info , matches , content ): return 200 , [( b 'content-type' , b 'text/plain' )], text_writer ( info [ 'message' ]) app = Application ( info = { 'message' : 'This is not a test' }) app . http_router . add ({ 'GET' }, '/test' , http_request_callback ) uvicorn . run ( app , port = 9009 ) The callback is defined on lines 4-5. The first argument scope is the dictionary passed straight through from the ASGI connection . The second argument info is client data passed into the server on line 7. This provides a mechanism for passing data around the application without the need for global variables. The third argument matches contains a dictionary of the variables which matched parts of the request url. As this route definition contained nothing to match this will be empty. The fourth and last argument content is an asynchronous iterator which provides the content of the request, and is not used here. The callback returns three things: the status code, a list of headers, and a writer. The headers are supplied as a list of name-value byte tuples. This is how the ASGI server expectes them, so no extra work need be done. The writer is an async iterator, meaning that the response supports streaming from the ground up. The application is created on line 7 with some client data containing the message to send. The route to the callback function is defined on line 8. As this in an HTTP route (rather than a websocket route) the http_router is used. The first argument to the router is the set of methods supported. These must be uppercase strings. The second argument as the path. This may contain matching variables, but in this case is a simple absolute path. The last argument is the HTTP response callback. Finally the web server is started on line 10. Rest Server \u00b6 The following example provides a simple REST service. A GET on the /info andpoint returns the contents of the info object, while a POST overwrites the INFO object with the contents of the body converted from json. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import json from bareasgi import Application , text_reader , text_writer import uvicorn async def get_info ( scope , info , matches , content ): text = json . dumps ( info ) return 200 , [( b 'content-type' , b 'application/json' )], text_writer ( text ) async def set_info ( scope , info , matches , content ): text = await text_reader ( content ) data = json . loads ( text ) info . update ( data ) return 204 app = Application ( info = { 'name' : 'Michael Caine' }) app . http_router . add ({ 'GET' }, '/info' , get_info ) app . http_router . add ({ 'POST' }, '/info' , set_info ) uvicorn . run ( app , port = 9009 ) This example demonstrates how the content can be retrieved from the request on line 10. Note how lightweight the response (on line 13) is, with simply the 204 (success not content) returned. Websocket Handler \u00b6 The following fragment shows a websocket callback. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 async def websocket_callback ( scope , info , matches , web_socket ): await web_socket . accept () try : while True : text = await web_socket . receive () if text is None : break await web_socket . send ( 'You said: ' + text ) except Exception as error : print ( error ) await web_socket . close () app = Application () app . ws_router . add ( '/test' , websocket_callback ) The web_socket object supplied on line 1 provides four methods: accept - to accept the web socket. This must be called first. receive - to read from the socket. When closed by the client None is returned. send - to write to the socket. close - to close the socket.","title":"Examples"},{"location":"user-guide/examples/#examples","text":"Here are some examples. More can be found in the github repository here . All the examples use the uvicorn server.","title":"Examples"},{"location":"user-guide/examples/#simple","text":"Here is a trivial example which registers a single http request callback at the endpoint /test and responds with the plain text This is not a test . 1 2 3 4 5 6 7 8 9 10 from bareasgi import Application , text_writer import uvicorn async def http_request_callback ( scope , info , matches , content ): return 200 , [( b 'content-type' , b 'text/plain' )], text_writer ( info [ 'message' ]) app = Application ( info = { 'message' : 'This is not a test' }) app . http_router . add ({ 'GET' }, '/test' , http_request_callback ) uvicorn . run ( app , port = 9009 ) The callback is defined on lines 4-5. The first argument scope is the dictionary passed straight through from the ASGI connection . The second argument info is client data passed into the server on line 7. This provides a mechanism for passing data around the application without the need for global variables. The third argument matches contains a dictionary of the variables which matched parts of the request url. As this route definition contained nothing to match this will be empty. The fourth and last argument content is an asynchronous iterator which provides the content of the request, and is not used here. The callback returns three things: the status code, a list of headers, and a writer. The headers are supplied as a list of name-value byte tuples. This is how the ASGI server expectes them, so no extra work need be done. The writer is an async iterator, meaning that the response supports streaming from the ground up. The application is created on line 7 with some client data containing the message to send. The route to the callback function is defined on line 8. As this in an HTTP route (rather than a websocket route) the http_router is used. The first argument to the router is the set of methods supported. These must be uppercase strings. The second argument as the path. This may contain matching variables, but in this case is a simple absolute path. The last argument is the HTTP response callback. Finally the web server is started on line 10.","title":"Simple"},{"location":"user-guide/examples/#rest-server","text":"The following example provides a simple REST service. A GET on the /info andpoint returns the contents of the info object, while a POST overwrites the INFO object with the contents of the body converted from json. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import json from bareasgi import Application , text_reader , text_writer import uvicorn async def get_info ( scope , info , matches , content ): text = json . dumps ( info ) return 200 , [( b 'content-type' , b 'application/json' )], text_writer ( text ) async def set_info ( scope , info , matches , content ): text = await text_reader ( content ) data = json . loads ( text ) info . update ( data ) return 204 app = Application ( info = { 'name' : 'Michael Caine' }) app . http_router . add ({ 'GET' }, '/info' , get_info ) app . http_router . add ({ 'POST' }, '/info' , set_info ) uvicorn . run ( app , port = 9009 ) This example demonstrates how the content can be retrieved from the request on line 10. Note how lightweight the response (on line 13) is, with simply the 204 (success not content) returned.","title":"Rest Server"},{"location":"user-guide/examples/#websocket-handler","text":"The following fragment shows a websocket callback. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 async def websocket_callback ( scope , info , matches , web_socket ): await web_socket . accept () try : while True : text = await web_socket . receive () if text is None : break await web_socket . send ( 'You said: ' + text ) except Exception as error : print ( error ) await web_socket . close () app = Application () app . ws_router . add ( '/test' , websocket_callback ) The web_socket object supplied on line 1 provides four methods: accept - to accept the web socket. This must be called first. receive - to read from the socket. When closed by the client None is returned. send - to write to the socket. close - to close the socket.","title":"Websocket Handler"},{"location":"user-guide/h2/","text":"HTTP/2 \u00b6 Overview \u00b6 Upgrading to HTTP/2 is largely transparent. It requires: an ASGI server which supports is (e.g. Hypercorn ) TLS incryption HTTP Push \u00b6 There is a feature called HTTP/2 server push which allows the server to notify the client of urls required by the document being served before the client has received the document. This can be implemented in the following manner: async def test_page ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse : html = \"\"\" <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>Example 1</title> <script src=\"/clickHandler.js\"></script> </head> <body> <h1>Example 1</h1> <button type=\"button\" onclick=\"handleClick('here')\"> Click me </button> <p id=\"here\" /> </body> </html> \"\"\" pushes = [ ( '/clickhandler.js' , [( b 'accept' , b 'text/javascript' )]) ] return 200 , [( b 'content-type' , b 'text/html' )], text_writer ( html ), pushes","title":"HTTP/2"},{"location":"user-guide/h2/#http2","text":"","title":"HTTP/2"},{"location":"user-guide/h2/#overview","text":"Upgrading to HTTP/2 is largely transparent. It requires: an ASGI server which supports is (e.g. Hypercorn ) TLS incryption","title":"Overview"},{"location":"user-guide/h2/#http-push","text":"There is a feature called HTTP/2 server push which allows the server to notify the client of urls required by the document being served before the client has received the document. This can be implemented in the following manner: async def test_page ( scope : Scope , info : Info , matches : RouteMatches , content : Content ) -> HttpResponse : html = \"\"\" <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>Example 1</title> <script src=\"/clickHandler.js\"></script> </head> <body> <h1>Example 1</h1> <button type=\"button\" onclick=\"handleClick('here')\"> Click me </button> <p id=\"here\" /> </body> </html> \"\"\" pushes = [ ( '/clickhandler.js' , [( b 'accept' , b 'text/javascript' )]) ] return 200 , [( b 'content-type' , b 'text/html' )], text_writer ( html ), pushes","title":"HTTP Push"},{"location":"user-guide/installation/","text":"Installation \u00b6 The package can be installed with pip. pip install bareasgi This is a Python3.7 and later package.","title":"Installation"},{"location":"user-guide/installation/#installation","text":"The package can be installed with pip. pip install bareasgi This is a Python3.7 and later package.","title":"Installation"},{"location":"user-guide/io/","text":"Reading and Writing \u00b6 Reading and writing body content is performed with asynchronous iterators and generators. Note that the content is sent and received in bytes. Reading \u00b6 Here is a simple example of a reader that consumes all the body content and returns a string. async def text_reader ( content : Content ) -> str : text = '' async for b in content : text += b . decode () return text This mechanism means that no unnecessary work is done. For example if the content type was invalid it would be pointless to decode the body. Also if inconsistent data was found an error can be returned rather than reading all the data. Writing \u00b6 Here is a simple example of a reader that returns the body content as an async generator. async def text_writer ( text : str ) -> AsyncGenerator [ bytes , None ]: n = 512 while text : yield text [: n ] . encode () text = text [ n :] Breaking up the message in this manner allows the ASGI server more control over the data sent. If the receiving client decides to stop consuming the data, the remaining body need never be sent. Usage \u00b6 We might use these functions in a handler in the following manner: async def set_info ( scope , info , matches , content ): text = await text_reader ( content ) return 204 , None , text_writer ( f 'You said \" {text} \"' ) Notice how the text_reader is awaited. Chunking \u00b6 If content is sent without any headers an ASGI server will add the header transfer-encoding set to chunking . In this mode the server will send out each part of the body in length prefixed \"chunks\". If the content length is known and a content-length header is set, the ASGI server will not add the chunked transfer encoding, but you can still send the data in multiple parts. If the content length is incorrect, the ASGI server will not help you, and the receiver will be unable to properly receive the response.","title":"Reading and Writing"},{"location":"user-guide/io/#reading-and-writing","text":"Reading and writing body content is performed with asynchronous iterators and generators. Note that the content is sent and received in bytes.","title":"Reading and Writing"},{"location":"user-guide/io/#reading","text":"Here is a simple example of a reader that consumes all the body content and returns a string. async def text_reader ( content : Content ) -> str : text = '' async for b in content : text += b . decode () return text This mechanism means that no unnecessary work is done. For example if the content type was invalid it would be pointless to decode the body. Also if inconsistent data was found an error can be returned rather than reading all the data.","title":"Reading"},{"location":"user-guide/io/#writing","text":"Here is a simple example of a reader that returns the body content as an async generator. async def text_writer ( text : str ) -> AsyncGenerator [ bytes , None ]: n = 512 while text : yield text [: n ] . encode () text = text [ n :] Breaking up the message in this manner allows the ASGI server more control over the data sent. If the receiving client decides to stop consuming the data, the remaining body need never be sent.","title":"Writing"},{"location":"user-guide/io/#usage","text":"We might use these functions in a handler in the following manner: async def set_info ( scope , info , matches , content ): text = await text_reader ( content ) return 204 , None , text_writer ( f 'You said \" {text} \"' ) Notice how the text_reader is awaited.","title":"Usage"},{"location":"user-guide/io/#chunking","text":"If content is sent without any headers an ASGI server will add the header transfer-encoding set to chunking . In this mode the server will send out each part of the body in length prefixed \"chunks\". If the content length is known and a content-length header is set, the ASGI server will not add the chunked transfer encoding, but you can still send the data in multiple parts. If the content length is incorrect, the ASGI server will not help you, and the receiver will be unable to properly receive the response.","title":"Chunking"},{"location":"user-guide/middleware/","text":"Middleware \u00b6 Middleware is a chain of functions terminated by a callback. It can be used to add content to the request and response or to control the calling of subsequent handlers. A middleware callback is an async function with the following prototype. status , headers , content , pushes = await fn ( scope , info , matches , content , callback ) This is the same as an HTTP handler, with the addition of the callback which is either another middleware callback or an HTTP handler. Simple Example \u00b6 Here is a simple middleware example. import uvicorn from bareasgi import Application , text_writer async def first_middleware ( scope , info , matches , content , handler ): info [ 'message' ] = 'This is first the middleware. ' response = await handler ( scope , info , matches , content ) return response async def second_middleware ( scope , info , matches , content , handler ): info [ 'message' ] += 'This is the second middleware.' response = await handler ( scope , info , matches , content ) return response async def http_request_callback ( scope , info , matches , content ): return 200 , [( b 'content-type' , b 'text/plain' )], text_writer ( info [ 'message' ]) app = Application ( middlewares = [ first_middleware , second_middleware ]) app . http_router . add ({ 'GET' }, '/test' , http_request_callback ) uvicorn . run ( app , port = 9009 )","title":"Middleware"},{"location":"user-guide/middleware/#middleware","text":"Middleware is a chain of functions terminated by a callback. It can be used to add content to the request and response or to control the calling of subsequent handlers. A middleware callback is an async function with the following prototype. status , headers , content , pushes = await fn ( scope , info , matches , content , callback ) This is the same as an HTTP handler, with the addition of the callback which is either another middleware callback or an HTTP handler.","title":"Middleware"},{"location":"user-guide/middleware/#simple-example","text":"Here is a simple middleware example. import uvicorn from bareasgi import Application , text_writer async def first_middleware ( scope , info , matches , content , handler ): info [ 'message' ] = 'This is first the middleware. ' response = await handler ( scope , info , matches , content ) return response async def second_middleware ( scope , info , matches , content , handler ): info [ 'message' ] += 'This is the second middleware.' response = await handler ( scope , info , matches , content ) return response async def http_request_callback ( scope , info , matches , content ): return 200 , [( b 'content-type' , b 'text/plain' )], text_writer ( info [ 'message' ]) app = Application ( middlewares = [ first_middleware , second_middleware ]) app . http_router . add ({ 'GET' }, '/test' , http_request_callback ) uvicorn . run ( app , port = 9009 )","title":"Simple Example"},{"location":"user-guide/optional-packages/","text":"Optional Packages \u00b6 The following packages provide additional functionality: bareASGI-cors for CORS support. bareASGI-static for serving static files. bareASGI-jinja2 for templating with jinja2. bareASGI-graphql-next for GraphQL support. bareASGI-prometheus for Prometheus metrics middleware. bareClient a lightweight HTTP client.","title":"Optional Packages"},{"location":"user-guide/optional-packages/#optional-packages","text":"The following packages provide additional functionality: bareASGI-cors for CORS support. bareASGI-static for serving static files. bareASGI-jinja2 for templating with jinja2. bareASGI-graphql-next for GraphQL support. bareASGI-prometheus for Prometheus metrics middleware. bareClient a lightweight HTTP client.","title":"Optional Packages"},{"location":"user-guide/routing/","text":"Routing \u00b6 The routers are split into two: HTTP and WebSockets. A basic router is provided, but this can be replaced if required. HttpRouter \u00b6 The HTTP router has the following structure: class HttpRouter : @property def not_found_response ( self ): ... @not_found_response . setter def not_found_response ( self , value : HttpResponse ): ... def add ( self , methods : AbstractSet [ str ], path : str , callback : HttpRequestCallback ) -> None : ... def __call__ ( self , scope : Scope ) -> Tuple [ Optional [ HttpRequestCallback ], Optional [ RouteMatches ]]: ... WebSocketRouter \u00b6 The WebSocket router has the following structure: class WebSocketRouter ( metaclass = ABCMeta ): def add ( self , path : str , callback : WebSocketRequestCallback ) -> None : ... def __call__ ( self , scope : Scope ) -> Tuple [ Optional [ WebSocketRequestCallback ], Optional [ RouteMatches ]]: ... Paths \u00b6 Here are some example paths: literal_path = '/foo/bar' capture_trailing_paths = '/foo/ {path} ' variables_path = '/foo/ {name} /{id:int}/{created:datetime:%Y-%m- %d }' Matched path segments are passed in to the handlers as a dictionary of route matches.","title":"Routing"},{"location":"user-guide/routing/#routing","text":"The routers are split into two: HTTP and WebSockets. A basic router is provided, but this can be replaced if required.","title":"Routing"},{"location":"user-guide/routing/#httprouter","text":"The HTTP router has the following structure: class HttpRouter : @property def not_found_response ( self ): ... @not_found_response . setter def not_found_response ( self , value : HttpResponse ): ... def add ( self , methods : AbstractSet [ str ], path : str , callback : HttpRequestCallback ) -> None : ... def __call__ ( self , scope : Scope ) -> Tuple [ Optional [ HttpRequestCallback ], Optional [ RouteMatches ]]: ...","title":"HttpRouter"},{"location":"user-guide/routing/#websocketrouter","text":"The WebSocket router has the following structure: class WebSocketRouter ( metaclass = ABCMeta ): def add ( self , path : str , callback : WebSocketRequestCallback ) -> None : ... def __call__ ( self , scope : Scope ) -> Tuple [ Optional [ WebSocketRequestCallback ], Optional [ RouteMatches ]]: ...","title":"WebSocketRouter"},{"location":"user-guide/routing/#paths","text":"Here are some example paths: literal_path = '/foo/bar' capture_trailing_paths = '/foo/ {path} ' variables_path = '/foo/ {name} /{id:int}/{created:datetime:%Y-%m- %d }' Matched path segments are passed in to the handlers as a dictionary of route matches.","title":"Paths"},{"location":"user-guide/server-sent-events/","text":"Server Sent Events \u00b6 Server sent events can be implemented by providing an endpoint with an async generator. The following program provides an endpoint test_page for the html document which contains the JavaScript code to create the EventSource with a url served by the test_events function. This function returnes as the body an async generator which sends the time every second. When the event source is closed the task will be cancelled and the function exits. import asyncio from bareasgi import Application , text_writer from datetime import datetime import uvicorn async def test_page ( scope , info , matches , content ): html = \"\"\" <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>Example</title> </head> <body> <h1>Server Sent Events</h1> Time: <snap id=\"time\"></span> <script> var eventSource = new EventSource(\"http://localhost:9009/events\") eventSource.onmessage = function(event) { element = document.getElementById(\"time\") element.innerHTML = event.data } </script> </body> </html> \"\"\" return 200 , [( b 'content-type' , b 'text/html' )], text_writer ( html ) async def test_events ( scope , info , matches , content ): async def send_events (): is_cancelled = False while not is_cancelled : try : yield f 'data: {datetime.now()} \\n\\n\\n ' . encode ( 'utf-8' ) # Defeat buffering by giving the server a nudge. yield ': \\n\\n\\n ' . encode ( 'utf-8' ) await asyncio . sleep ( 1 ) except asyncio . CancelledError : is_cancelled = True headers = [ ( b 'cache-control' , b 'no-cache' ), ( b 'content-type' , b 'text/event-stream' ), ( b 'connection' , b 'keep-alive' ) ] return 200 , headers , send_events () app = Application () app . http_router . add ({ 'GET' }, '/' , index ) app . http_router . add ({ 'GET' }, '/test' , test_page ) app . http_router . add ({ 'GET' }, '/events' , test_events ) uvicorn . run ( app , host = 'localhost' , port = 9009 ) Note that we set the host to \"localhost\" to avoid CORS errors. Also, most ASGI servers (all the ones I've tried) buffer streaming data. The effect of this is that an event gets sent when the next event is yielded. We can defeat this by sending an SSE comment \":\\\\n\\\\n\\\\n\" . In the above example this can be seen by increasing the time tick from 1 second to 5 seconds, and observing the raw event stream in the Network tab of dev-tools in the browser. Without the \"nudge\" the timestamp is always out by the sleep interval.","title":"Server Sent Events"},{"location":"user-guide/server-sent-events/#server-sent-events","text":"Server sent events can be implemented by providing an endpoint with an async generator. The following program provides an endpoint test_page for the html document which contains the JavaScript code to create the EventSource with a url served by the test_events function. This function returnes as the body an async generator which sends the time every second. When the event source is closed the task will be cancelled and the function exits. import asyncio from bareasgi import Application , text_writer from datetime import datetime import uvicorn async def test_page ( scope , info , matches , content ): html = \"\"\" <!DOCTYPE html> <html> <head> <meta charset=\"utf-8\"> <title>Example</title> </head> <body> <h1>Server Sent Events</h1> Time: <snap id=\"time\"></span> <script> var eventSource = new EventSource(\"http://localhost:9009/events\") eventSource.onmessage = function(event) { element = document.getElementById(\"time\") element.innerHTML = event.data } </script> </body> </html> \"\"\" return 200 , [( b 'content-type' , b 'text/html' )], text_writer ( html ) async def test_events ( scope , info , matches , content ): async def send_events (): is_cancelled = False while not is_cancelled : try : yield f 'data: {datetime.now()} \\n\\n\\n ' . encode ( 'utf-8' ) # Defeat buffering by giving the server a nudge. yield ': \\n\\n\\n ' . encode ( 'utf-8' ) await asyncio . sleep ( 1 ) except asyncio . CancelledError : is_cancelled = True headers = [ ( b 'cache-control' , b 'no-cache' ), ( b 'content-type' , b 'text/event-stream' ), ( b 'connection' , b 'keep-alive' ) ] return 200 , headers , send_events () app = Application () app . http_router . add ({ 'GET' }, '/' , index ) app . http_router . add ({ 'GET' }, '/test' , test_page ) app . http_router . add ({ 'GET' }, '/events' , test_events ) uvicorn . run ( app , host = 'localhost' , port = 9009 ) Note that we set the host to \"localhost\" to avoid CORS errors. Also, most ASGI servers (all the ones I've tried) buffer streaming data. The effect of this is that an event gets sent when the next event is yielded. We can defeat this by sending an SSE comment \":\\\\n\\\\n\\\\n\" . In the above example this can be seen by increasing the time tick from 1 second to 5 seconds, and observing the raw event stream in the Network tab of dev-tools in the browser. Without the \"nudge\" the timestamp is always out by the sleep interval.","title":"Server Sent Events"},{"location":"user-guide/ssl/","text":"SSL/HTTPS \u00b6 Overview \u00b6 The following describes how to start some ASGI servers supporting SSL/HTTPS. You can find information on creating self signed certificates here . Uvicorn \u00b6 import uvicorn ... uvicorn . run ( app , host = '127.0.0.1' , port = 8008 , ssl_keyfile = 'foo.key' , ssl_certfile = 'foo.crt' ) Hypercorn \u00b6 import asyncio from hypercorn.asyncio import serve from hypercorn.config import Config ... config = hypercorn . Config () config . bind = [ '0.0.0.0:8008' ] config . keyfile = 'foo.key' config . certfile = 'foo.crt' asyncio . run ( serve ( app , web_config ))","title":"SSL/HTTPS"},{"location":"user-guide/ssl/#sslhttps","text":"","title":"SSL/HTTPS"},{"location":"user-guide/ssl/#overview","text":"The following describes how to start some ASGI servers supporting SSL/HTTPS. You can find information on creating self signed certificates here .","title":"Overview"},{"location":"user-guide/ssl/#uvicorn","text":"import uvicorn ... uvicorn . run ( app , host = '127.0.0.1' , port = 8008 , ssl_keyfile = 'foo.key' , ssl_certfile = 'foo.crt' )","title":"Uvicorn"},{"location":"user-guide/ssl/#hypercorn","text":"import asyncio from hypercorn.asyncio import serve from hypercorn.config import Config ... config = hypercorn . Config () config . bind = [ '0.0.0.0:8008' ] config . keyfile = 'foo.key' config . certfile = 'foo.crt' asyncio . run ( serve ( app , web_config ))","title":"Hypercorn"},{"location":"user-guide/usage/","text":"Usage \u00b6 The following trival example uses the uvicorn server. See here for more. import uvicorn import json from bareasgi import Application , text_reader , text_writer async def get_info ( scope , info , matches , content ): text = json . dumps ( info ) return 200 , [( b 'content-type' , b 'application/json' )], text_writer ( text ) async def set_info ( scope , info , matches , content ): text = await text_reader ( content ) data = json . loads ( text ) info . update ( data ) return 204 app = Application ( info = { 'name' : 'Michael Caine' }) app . http_router . add ({ 'GET' }, '/info' , get_info ) app . http_router . add ({ 'POST' }, '/info' , set_info ) uvicorn . run ( app , port = 9009 ) The above example demonstrates some of the key features of this implementation. All the handler arguments are simple Python objects (list, dict, tuple, etc). Arguments like scope are passed directly from the ASGI server without being processed into helper classes. All features (even JSON encoding) are the responsibility of the application, not the framework. Handlers are asynchronous. The text_writer function is a simple wrapper which turns text into an async byte stream.","title":"Usage"},{"location":"user-guide/usage/#usage","text":"The following trival example uses the uvicorn server. See here for more. import uvicorn import json from bareasgi import Application , text_reader , text_writer async def get_info ( scope , info , matches , content ): text = json . dumps ( info ) return 200 , [( b 'content-type' , b 'application/json' )], text_writer ( text ) async def set_info ( scope , info , matches , content ): text = await text_reader ( content ) data = json . loads ( text ) info . update ( data ) return 204 app = Application ( info = { 'name' : 'Michael Caine' }) app . http_router . add ({ 'GET' }, '/info' , get_info ) app . http_router . add ({ 'POST' }, '/info' , set_info ) uvicorn . run ( app , port = 9009 ) The above example demonstrates some of the key features of this implementation. All the handler arguments are simple Python objects (list, dict, tuple, etc). Arguments like scope are passed directly from the ASGI server without being processed into helper classes. All features (even JSON encoding) are the responsibility of the application, not the framework. Handlers are asynchronous. The text_writer function is a simple wrapper which turns text into an async byte stream.","title":"Usage"}]}